<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Battleboard — Dice & UI Tweaks</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<div class="wrap">
  <header>
    <div id="turnDisplay">Player 1's Turn</div>
    <div style="display:flex;gap:8px;align-items:center">
      <button id="endTurnBtn">End Turn</button>
    </div>
    <div>
      <button id="saveBtn">Save</button>
      <button id="loadBtn">Load</button>
    </div>
  </header>

  <div id="boardPanel">
    <div id="board" role="grid" aria-label="game board"></div>

    <!-- battle overlay (hidden until an attack) -->
    <div id="battleOverlay" aria-hidden="true" style="display:none">
      <div class="diceBox" id="diceBox" role="dialog" aria-modal="true">
        <button class="closeBtn" id="diceClose" title="Close">x</button>
        <div style="display:flex;justify-content:space-between;align-items:center;width:100%">
          <div style="font-weight:900">Battle</div>
        </div>
        <div class="diceTotals">
          <div class="diceLabel">Attacker (<span id="attCount">0</span>)</div>
          <div class="diceLabel">Defender (<span id="defCount">0</span>)</div>
        </div>
        <div id="attRow" class="diceRow"></div>
        <div style="height:8px"></div>
        <div id="defRow" class="diceRow"></div>
        <div style="height:10px"></div>
        <div style="width:100%;display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:900">Totals</div>
          <div style="display:flex;gap:12px;align-items:center">
            <div style="font-size:20px;font-weight:900" id="attTotal">0</div>
            <div style="opacity:.5">vs</div>
            <div style="font-size:20px;font-weight:900" id="defTotal">0</div>
          </div>
        </div>
      </div>
    </div>

    <div id="battleLog" aria-live="polite"></div>
  </div>

  <div id="info"></div>
</div>

<script>

const params = new URLSearchParams(window.location.search);
let players = parseInt(params.get('players')) || 2;
if (Number.isNaN(players)) players = 2;
players = Math.max(2, Math.min(8, players));

// Use board size from URL parameter, default to 10 if missing
let boardSize = parseInt(params.get('board')) || 10;
if (Number.isNaN(boardSize)) boardSize = 10;
boardSize = Math.max(5, Math.min(20, boardSize)); // Clamp to allowed range

const playerColors = ["#ff7b7b","#7bb8ff","#7bff9b","#ffcf7b","#be7bff","#4dd2d2","#ff88d1","#e6e66a"];
const playerData = Array.from({length:players}, (_,i)=>({id:i+1,color:playerColors[i],territories:0,totalPieces:0,alive:true}));

// DOM refs
const boardEl = document.getElementById('board');
const turnDisplay = document.getElementById('turnDisplay');
const endTurnBtn = document.getElementById('endTurnBtn');
const infoEl = document.getElementById('info');
const battleLogEl = document.getElementById('battleLog');
const battleOverlay = document.getElementById('battleOverlay');
const attRow = document.getElementById('attRow');
const defRow = document.getElementById('defRow');
const attTotalEl = document.getElementById('attTotal');
const defTotalEl = document.getElementById('defTotal');
const attCountEl = document.getElementById('attCount');
const defCountEl = document.getElementById('defCount');
const saveBtn = document.getElementById('saveBtn');
const loadBtn = document.getElementById('loadBtn');
const diceCloseBtn = document.getElementById('diceClose');

let diceHideTimer = null;

// build board
boardEl.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
boardEl.style.gridTemplateRows = `repeat(${boardSize}, 1fr)`;
const totalCells = boardSize * boardSize;
const cells = new Array(totalCells);
for (let i=0;i<totalCells;i++){
  const el = document.createElement('div');
  el.className = 'cell';
  el.dataset.index = i;
  boardEl.appendChild(el);
  cells[i] = { index: i, element: el, owner: null, pieces: 0 };
}

// utilities
function shuffle(array){ for(let i=array.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [array[i],array[j]]=[array[j],array[i]];} return array; }
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function textColorForHex(hex){ const h=hex.replace('#',''); const r=parseInt(h.substring(0,2),16); const g=parseInt(h.substring(2,4),16); const b=parseInt(h.substring(4,6),16); return ((r*299+g*587+b*114)/1000)>150 ? '#000' : '#fff'; }
function indexToRC(idx){ return { r: Math.floor(idx/boardSize), c: idx%boardSize }; }
function isAdjacent(i1,i2){ const a=indexToRC(i1), b=indexToRC(i2); return Math.abs(a.r-b.r)+Math.abs(a.c-b.c)===1; }

// render helpers
function updateCell(cell){
  const el = cell.element;
  if (cell.owner){
    const color = playerData[cell.owner-1].color;
    el.style.background = color;
    el.style.color = textColorForHex(color);
    let counter = el.querySelector('.cnt');
    if (!counter){ counter = document.createElement('div'); counter.className = 'cnt'; counter.style.pointerEvents='none'; el.innerHTML = ''; el.appendChild(counter); }
    counter.textContent = cell.pieces;
    el.title = `Player ${cell.owner} — Pieces: ${cell.pieces}`;
  } else {
    el.style.background = '#222';
    el.style.color = '#fff';
    el.innerHTML = '';
    el.title = 'Neutral';
  }
}

// animate numeric tween
function animateNumber(cellObj, newVal, duration = 500){
  if (!cellObj || !cellObj.element) return;
  const el = cellObj.element.querySelector('.cnt') || cellObj.element;
  const start = cellObj.pieces;
  const steps = Math.max(6, Math.floor(duration/40));
  let step = 0;
  const diff = newVal - start;
  const t = setInterval(()=>{
    step++;
    const val = Math.round(start + diff * (step / steps));
    el.textContent = val;
    if (step >= steps){
      clearInterval(t);
      el.textContent = newVal;
    }
  }, Math.max(8, duration/steps));
  cellObj.pieces = newVal;
}

// render player info badges
function recalcPlayerTotals(){ playerData.forEach(p=>{p.territories=0;p.totalPieces=0}); cells.forEach(c=>{ if (c.owner){ const p=playerData[c.owner-1]; if (p){ p.territories++; p.totalPieces+=c.pieces; } }}); playerData.forEach(p=>p.alive = p.territories>0); }
function renderPlayerInfo(){ recalcPlayerTotals(); infoEl.innerHTML=''; playerData.forEach(p=>{ const badge=document.createElement('div'); badge.className='player-badge'; badge.innerHTML=`<div class="swatch" style="background:${p.color}"></div><div>P${p.id}</div><div style="opacity:.7">T:${p.territories}</div><div style="opacity:.7">S:${p.totalPieces}</div>`; infoEl.appendChild(badge); }); }

// initial distribution (random round-robin) with random pieces 1..5
function assignStartingCells(){
  const indices = shuffle(Array.from({length:totalCells}, (_,i)=>i));
  for (let i=0;i<indices.length;i++){
    const idx = indices[i];
    const pIdx = i % players;
    const cell = cells[idx];
    cell.owner = pIdx+1;
    cell.pieces = randInt(1,5);
    updateCell(cell);
  }
  renderPlayerInfo();
}

/* Reinforcement distribution */
const MAX_PAWNS_PER_CELL = 20;
function distributeReinforcementsForPlayer(playerId){
  const owned = cells.filter(c=>c.owner===playerId);
  if (owned.length === 0) return;
  const totalIncome = owned.length;
  if (totalIncome <= 0) return;

  let recipients = owned.filter(c => c.pieces < MAX_PAWNS_PER_CELL).map(c=>c.index);

  for (let i=0;i<totalIncome;i++){
    if (recipients.length === 0) break;
    const pick = recipients[Math.floor(Math.random()*recipients.length)];
    const cell = cells[pick];
    if (!cell) { recipients = recipients.filter(idx => idx !== pick); continue; }
    if (cell.pieces >= MAX_PAWNS_PER_CELL) { recipients = recipients.filter(idx => idx !== pick); continue; }

    // particle spawn
    const rect = boardEl.getBoundingClientRect();
    const sx = rect.width/2;
    const sy = -20;
    const rectCell = cell.element.getBoundingClientRect();
    const panelRect = boardEl.getBoundingClientRect();
    const tx = rectCell.left + rectCell.width/2 - panelRect.left;
    const ty = rectCell.top + rectCell.height/2 - panelRect.top;
    const particle = document.createElement('div');
    particle.className = 'pawnParticle';
    particle.style.left = `${sx}px`; particle.style.top = `${sy}px`; particle.style.background = playerData[playerId-1].color; particle.style.opacity = '1';
    boardEl.appendChild(particle);
    requestAnimationFrame(()=>{ particle.style.left = `${tx}px`; particle.style.top = `${ty}px`; particle.style.transform = 'translate(-50%,-50%) scale(1.05)'; });
    setTimeout(()=>{ particle.style.opacity='0'; setTimeout(()=>{ particle.remove(); }, 480); }, 600);

    setTimeout(()=>{
      if (cell.pieces < MAX_PAWNS_PER_CELL) {
        animateNumber(cell, Math.min(MAX_PAWNS_PER_CELL, cell.pieces+1), 360);
        renderPlayerInfo();
        if (cell.pieces >= MAX_PAWNS_PER_CELL) {
          recipients = recipients.filter(idx => idx !== pick);
        }
      }
    }, 420 + Math.random()*120);
  }
}

/* Audio helpers (unchanged) */
const AudioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
function playTone(freq, dur=0.08, type='sine', gain=0.09){ if (!AudioCtx) return; const o = AudioCtx.createOscillator(); const g = AudioCtx.createGain(); o.type = type; o.frequency.value = freq; g.gain.value = gain; o.connect(g); g.connect(AudioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, AudioCtx.currentTime + dur); setTimeout(()=> o.stop(), dur*1000+20); }
function playDiceRollSound(){ playTone(1200,0.05,'square',0.08); setTimeout(()=> playTone(950,0.05,'square',0.07), 60); setTimeout(()=> playTone(700,0.05,'square',0.06), 120); }
function playCaptureSound(){ playTone(520,0.18,'sawtooth',0.14); setTimeout(()=> playTone(860,0.12,'triangle',0.06), 120); }
function playDefendSound(){ playTone(220,0.14,'sine',0.12); setTimeout(()=> playTone(140,0.08,'sine',0.06), 90); }

// dice rendering as pips (white dice, dark pips)
const diePipsMap = {
  1: [4],
  2: [0,8],
  3: [0,4,8],
  4: [0,2,6,8],
  5: [0,2,4,6,8],
  6: [0,2,3,5,6,8]
};
function renderDieFace(dieEl, value){
  dieEl.innerHTML = '';
  for (let i=0;i<9;i++){
    const slot = document.createElement('div');
    slot.style.width = '100%'; slot.style.height = '100%';
    slot.style.display = 'flex'; slot.style.alignItems='center'; slot.style.justifyContent='center';
    if (diePipsMap[value] && diePipsMap[value].includes(i)){
      const pip = document.createElement('div');
      pip.className = 'pip';
      slot.appendChild(pip);
    }
    dieEl.appendChild(slot);
  }
}

function showBattleLog(text, short=true){
  battleLogEl.textContent = text;
  battleLogEl.classList.add('show');
  clearTimeout(battleLogEl._t);
  battleLogEl._t = setTimeout(()=> battleLogEl.classList.remove('show'), short ? 1400 : 3200);
}

function clearDiceUI(){ attRow.innerHTML=''; defRow.innerHTML=''; attTotalEl.textContent='0'; defTotalEl.textContent='0'; attCountEl.textContent='0'; defCountEl.textContent='0'; }
function showDiceOverlay(attCount, defCount){
  battleOverlay.style.display='flex';
  battleOverlay.setAttribute('aria-hidden','false');
  attCountEl.textContent = attCount;
  defCountEl.textContent = defCount;
  clearDiceUI();
  for(let i=0;i<attCount;i++){ const d = document.createElement('div'); d.className='diceDie'; attRow.appendChild(d); }
  for(let i=0;i<defCount;i++){ const d = document.createElement('div'); d.className='diceDie'; defRow.appendChild(d); }
}
function hideDiceOverlayAfter(ms=3000){ clearTimeout(diceHideTimer); diceHideTimer = setTimeout(()=>{ battleOverlay.style.display='none'; battleOverlay.setAttribute('aria-hidden','true'); clearDiceUI(); }, ms); }
function hideDiceOverlayNow(){ clearTimeout(diceHideTimer); battleOverlay.style.display='none'; battleOverlay.setAttribute('aria-hidden','true'); clearDiceUI(); }

function rollDiceArray(n){ const out = []; for(let i=0;i<n;i++) out.push(randInt(1,6)); return out; }
function sumDice(arr){ return arr.reduce((a,b)=>a+b,0); }

function animateDiceRollFaces(finalAtt, finalDef, onDone){
  const attDice = Array.from(attRow.children);
  const defDice = Array.from(defRow.children);
  const rollTime = 1100;
  const interval = 80;
  const rounds = Math.floor(rollTime / interval);
  let r = 0;
  playDiceRollSound();
  const intervalId = setInterval(()=>{
    r++;
    attDice.forEach(d => renderDieFace(d, randInt(1,6)));
    defDice.forEach(d => renderDieFace(d, randInt(1,6)));
    if (r >= rounds){
      clearInterval(intervalId);
      attDice.forEach((d,i)=> renderDieFace(d, (finalAtt[i]||1)));
      defDice.forEach((d,i)=> renderDieFace(d, (finalDef[i]||1)));
      if (typeof onDone === 'function') onDone();
    }
  }, interval);
}

/* pawn animation */
function animatePawnTransfer(srcEl, tgtEl, color, count=1){
  const rectSrc = srcEl.getBoundingClientRect();
  const rectTgt = tgtEl.getBoundingClientRect();
  const panelRect = boardEl.getBoundingClientRect();
  const sx = rectSrc.left + rectSrc.width/2 - panelRect.left;
  const sy = rectSrc.top + rectSrc.height/2 - panelRect.top;
  const tx = rectTgt.left + rectTgt.width/2 - panelRect.left;
  const ty = rectTgt.top + rectTgt.height/2 - panelRect.top;

  const spawn = Math.min(6, Math.max(1, count));
  for (let i=0;i<spawn;i++){
    const particle = document.createElement('div');
    particle.className = 'pawnParticle';
    particle.style.left = `${sx + randInt(-6,6)}px`;
    particle.style.top = `${sy + randInt(-6,6)}px`;
    particle.style.background = color;
    particle.style.opacity = '1';
    boardEl.appendChild(particle);
    requestAnimationFrame(()=>{ particle.style.left = `${tx + randInt(-8,8)}px`; particle.style.top = `${ty + randInt(-8,8)}px`; particle.style.transform = 'translate(-50%,-50%) scale(1.15)'; });
    setTimeout(()=>{ particle.style.opacity='0'; setTimeout(()=> particle.remove(), 460); }, 580 + i*40);
  }
}

function shakeBoard(){ boardEl.classList.add('shake'); setTimeout(()=> boardEl.classList.remove('shake'), 450); }

/* Attack flow */
let locked = false;
function performAttackAnimated(srcIdx, tgtIdx){
  if (locked) return;
  const src = cells[srcIdx];
  const tgt = cells[tgtIdx];
  if (!src || !tgt) return;
  if (src.owner !== currentPlayer) return;
  if (!tgt.owner || tgt.owner === currentPlayer) return;
  if (!isAdjacent(srcIdx, tgtIdx)) return;

  const commitRaw = Math.max(0, src.pieces - 1);
  if (commitRaw <= 0){ showBattleLog('Cannot attack — must leave 1 behind.'); return; }

  const ATTACKER_DICE_CAP = 6;
  const DEFENDER_DICE_CAP = 6;
  const commit = Math.min(commitRaw, ATTACKER_DICE_CAP);
  const defDiceCount = Math.min(tgt.pieces, DEFENDER_DICE_CAP);

  locked = true;
  showDiceOverlay(commit, defDiceCount);

  const attDiceArr = rollDiceArray(commit);
  const defDiceArr = rollDiceArray(defDiceCount);

  animateDiceRollFaces(attDiceArr, defDiceArr, ()=>{
    const attSum = sumDice(attDiceArr);
    const defSum = sumDice(defDiceArr);
    attTotalEl.textContent = attSum;
    defTotalEl.textContent = defSum;

    const summary = `P${currentPlayer} (${attSum}) vs P${tgt.owner} (${defSum})`;

    if (attSum > defSum){
      playCaptureSound();
      animatePawnTransfer(src.element, tgt.element, playerData[currentPlayer-1].color, Math.min(8, commitRaw));
      const newSrcPieces = Math.max(1, src.pieces - commitRaw);
      animateNumber(src, newSrcPieces, 500);

      setTimeout(()=>{
        tgt.owner = currentPlayer;
        updateCell(tgt);
        const moveIn = Math.min(commitRaw, Math.max(1, commitRaw));
        animateNumber(tgt, moveIn, 600);
        renderPlayerInfo();
      }, 220);

      tgt.element.classList.add('flash-capture');
      setTimeout(()=> tgt.element.classList.remove('flash-capture'), 900);
      if (commitRaw >= 4 || defSum >= 8) shakeBoard();
      showBattleLog('Capture! ' + summary);

      hideDiceOverlayAfter(3000);
      setTimeout(()=>{ locked = false; if (!(src.owner === currentPlayer && src.pieces > 1)) clearSelection(); renderPlayerInfo(); checkPlayerElimination(); checkWinCondition(); }, 3000);

    } else {
      playDefendSound();
      const newSrcPieces = Math.max(1, src.pieces - commitRaw);
      animateNumber(src, newSrcPieces, 500);
      src.element.classList.add('flash-defend');
      setTimeout(()=> src.element.classList.remove('flash-defend'), 700);
      showBattleLog('Defended. ' + summary);
      hideDiceOverlayAfter(3000);
      setTimeout(()=>{ locked = false; if (!(src.owner === currentPlayer && src.pieces > 1)) clearSelection(); renderPlayerInfo(); checkPlayerElimination(); checkWinCondition(); }, 3000);
    }
  });
}

/* Turn state & UI interactions */
let currentPlayer = 1;
function updateTurnDisplay() { turnDisplay.textContent = `Player ${currentPlayer}'s Turn`; turnDisplay.style.color = playerData[currentPlayer - 1].color; }
function nextAlivePlayer(from){ for (let step=1; step<=players; step++){ const cand = ((from-1+step) % players) + 1; if (playerData[cand-1].alive) return cand; } return null; }
let endTurnCooldown = 0; let endTurnTimer = null;
function startEndTurnCooldown(seconds = 5) { endTurnBtn.disabled = true; endTurnCooldown = seconds; endTurnBtn.textContent = `End Turn (${endTurnCooldown})`; clearInterval(endTurnTimer); endTurnTimer = setInterval(() => { endTurnCooldown--; if (endTurnCooldown > 0) { endTurnBtn.textContent = `End Turn (${endTurnCooldown})`; } else { clearInterval(endTurnTimer); endTurnBtn.disabled = false; endTurnBtn.textContent = "End Turn"; } }, 1000); }

endTurnBtn.addEventListener('click', ()=>{ if (locked || endTurnBtn.disabled) return; distributeReinforcementsForPlayer(currentPlayer); const nxt = nextAlivePlayer(currentPlayer); if (nxt !== null && nxt !== currentPlayer) currentPlayer = nxt; updateTurnDisplay(); setTimeout(()=>{ renderPlayerInfo(); checkWinCondition(); }, 420); startEndTurnCooldown(5); });

function clearSelection(){ if (typeof selectedCell !== 'undefined' && selectedCell !== null) cells[selectedCell].element.classList.remove('selected'); selectedCell=null; }
let selectedCell = null;

function handleCellSelect(ev){
  if (locked) return;
  const el = ev.target.closest('.cell');
  if (!el) return;
  const idx = Number(el.dataset.index);
  const c = cells[idx];
  if (selectedCell === null){
    if (c.owner === currentPlayer){
      selectedCell = idx;
      c.element.classList.add('selected');
    }
    return;
  }
  if (selectedCell === idx){
    clearSelection();
    return;
  }
  if (c.owner === currentPlayer){
    cells[selectedCell].element.classList.remove('selected');
    selectedCell = idx;
    cells[selectedCell].element.classList.add('selected');
    return;
  }
  if (c.owner && c.owner !== currentPlayer){
    if (!isAdjacent(selectedCell, idx)){
      el.animate([{transform:'translateY(0)'},{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:160});
      return;
    }
    performAttackAnimated(selectedCell, idx);
  }
}

// Listen for both click and touchstart
boardEl.addEventListener('click', handleCellSelect);
boardEl.addEventListener('touchstart', function(ev){
  // Only handle single-finger taps
  if (ev.touches.length === 1) {
    handleCellSelect(ev);
    ev.preventDefault();
  }
}, {passive: false});

/* Improve outside click clearing */
document.addEventListener('click', (ev)=>{ if (!ev.target.closest('.cell') && !ev.target.closest('button') && !ev.target.closest('#diceBox')){ clearSelection(); } });
boardEl.addEventListener('dblclick', (ev)=>{ const el = ev.target.closest('.cell'); if (!el) return; const idx = Number(el.dataset.index); console.log(cells[idx]); });

/* Close button handler: hide overlay immediately (UI only) */
diceCloseBtn.addEventListener('click', ()=>{ hideDiceOverlayNow(); });

/* Player elimination & win checks */
function checkPlayerElimination(){ recalcPlayerTotals(); }
function checkWinCondition(){ recalcPlayerTotals(); const alivePlayers = playerData.filter(p=>p.alive); if (alivePlayers.length === 1){ const winner = alivePlayers[0]; setTimeout(()=> alert(`Player ${winner.id} wins!`), 40); } }

/* Save / Load */
function saveGameState() { const state = { currentPlayer, cells: cells.map(c => ({ owner: c.owner, pieces: c.pieces })), playerData: playerData.map(p => ({ id: p.id, color: p.color, territories: p.territories, totalPieces: p.totalPieces, alive: p.alive })), boardSize }; try { localStorage.setItem('squareLordsSave', JSON.stringify(state)); alert('Game state saved!'); } catch (e) { console.error('Save failed', e); alert('Failed to save game state.'); } }
function loadGameState() { const raw = localStorage.getItem('squareLordsSave'); if (!raw) { alert('No save found.'); return false; } try { const state = JSON.parse(raw); if (!state || !Array.isArray(state.cells) || state.cells.length !== cells.length){ alert('Incompatible save data.'); return false; } state.cells.forEach((c, i) => { cells[i].owner = c.owner; cells[i].pieces = c.pieces; updateCell(cells[i]); }); if (typeof state.currentPlayer === 'number') currentPlayer = state.currentPlayer; if (Array.isArray(state.playerData)){ state.playerData.forEach((p, i) => { if (playerData[i]) Object.assign(playerData[i], p); }); } updateTurnDisplay(); renderPlayerInfo(); alert('Game loaded.'); return true; } catch (e) { console.error('Failed to load save:', e); alert('Failed to load save data.'); return false; } }
saveBtn.addEventListener('click', saveGameState);
loadBtn.addEventListener('click', loadGameState);

/* Initialize game */
assignStartingCells();
updateTurnDisplay();

</script>
</body>
</html>
