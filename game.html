<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Battleboard — Dice & UI Tweaks</title>
<link rel="stylesheet" href="game-style.css">
</head>
<body>
<div class="wrap">
  <header>
    <div id="turnDisplay">Player 1's Turn</div>
    <div class="controls">
      <button id="endTurnBtn">End Turn</button>
    </div>
    <div>
      <button id="saveBtn">Save</button>
      <button id="loadBtn">Load</button>
    </div>
  </header>

  <div id="boardPanel">
    <div id="board" role="grid" aria-label="game board"></div>

    <!-- battle overlay (hidden until an attack) -->
  <div id="battleOverlay" aria-hidden="true">
      <div class="diceBox" id="diceBox" role="dialog" aria-modal="true">
        <button class="closeBtn" id="diceClose" title="Close">x</button>
        <div class="diceHeader">
          <div class="diceTitle">Battle</div>
        </div>
        <div class="diceTotals">
          <div class="diceLabel">Attacker (<span id="attCount">0</span>)</div>
          <div class="diceLabel">Defender (<span id="defCount">0</span>)</div>
        </div>
        <div id="attRow" class="diceRow"></div>
        <div class="spacer spacer-small"></div>
        <div id="defRow" class="diceRow"></div>
        <div class="spacer spacer-medium"></div>
        <div class="diceTotalsRow">
          <div class="diceTitle">Totals</div>
          <div class="diceTotalsRight">
            <div class="diceTotalValue" id="attTotal">0</div>
            <div class="muted">vs</div>
            <div class="diceTotalValue" id="defTotal">0</div>
          </div>
        </div>
      </div>
    </div>

    <div id="battleLog" aria-live="polite"></div>
  </div>

  <div id="info"></div>
</div>

<script>

/*
  SquareLords — game logic (inline)

  Overview:
  - Builds a square grid board and (optionally) some 1x2 spanning tiles
  - Tracks simple territory ownership and piece counts per primary cell
  - Allows selecting your own cell, attacking adjacent enemy cells using dice
  - Handles reinforcement distribution, save/load (localStorage), and small UI animations

  Important data shapes:
  - `cells` is an array with one entry per grid index. Primary cells have .primary=true and an .element.
    Covered indices (the second cell in a 1x2 span) are stored with primary=false and coveredBy -> primaryIndex.
  - `playerData` holds static player colours and computed totals.
  - `currentPlayer` is the active player id (1-based).

  This file only adds comments — no logic changes.
*/

// Read URL parameters (players, board, diffSquares)
const params = new URLSearchParams(window.location.search);
let players = parseInt(params.get('players')) || 2;
if (Number.isNaN(players)) players = 2;
players = Math.max(2, Math.min(8, players));

// Use board size from URL parameter, default to 10 if missing
let boardSize = parseInt(params.get('board')) || 10;
if (Number.isNaN(boardSize)) boardSize = 10;
boardSize = Math.max(5, Math.min(20, boardSize)); // Clamp to allowed range

// NEW FLAG: enable some 1x2 tiles when diffSquares=1 — creates a few 1x2 primary spans
const diffSquares = params.get('diffSquares') === '1';

// Predefined palette and a per-player data object (territories/totalPieces computed later)
const playerColors = ["#ff7b7b","#7bb8ff","#7bff9b","#ffcf7b","#be7bff","#4dd2d2","#ff88d1","#e6e66a"];
const playerData = Array.from({length:players}, (_,i)=>({id:i+1,color:playerColors[i],territories:0,totalPieces:0,alive:true,ally:null,pendingOfferFrom:null,pendingOfferTo:null,allyBlockedUntilRound:0}));

// DOM refs (cached frequently used elements)
const boardEl = document.getElementById('board');
const turnDisplay = document.getElementById('turnDisplay');
const endTurnBtn = document.getElementById('endTurnBtn');
const infoEl = document.getElementById('info');
const battleLogEl = document.getElementById('battleLog');
const battleOverlay = document.getElementById('battleOverlay');
const attRow = document.getElementById('attRow');
const defRow = document.getElementById('defRow');
const attTotalEl = document.getElementById('attTotal');
const defTotalEl = document.getElementById('defTotal');
const attCountEl = document.getElementById('attCount');
const defCountEl = document.getElementById('defCount');
const saveBtn = document.getElementById('saveBtn');
const loadBtn = document.getElementById('loadBtn');
const diceCloseBtn = document.getElementById('diceClose');

// Timer handle used to auto-hide the dice overlay
let diceHideTimer = null;

// --- Board construction ---
// We use CSS grid on #board and dynamically create only "primary" elements.
// Primary cells have an element and may span two grid indices when diffSquares is enabled.
// Non-primary (covered) cells hold metadata pointing back to their primary.
// The JS below computes the grid positions and creates DOM nodes accordingly.
// The grid template is set to repeat(boardSize) in both axes so each cell is 1fr.
// For 1x2 spans we set gridRowEnd or gridColumnEnd to `span 2` on the primary element.
// (This keeps layout simple and avoids creating DOM nodes for covered indices.)
// build board
boardEl.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
boardEl.style.gridTemplateRows = `repeat(${boardSize}, 1fr)`;
const totalCells = boardSize * boardSize;

// We'll keep an entry for every grid index. Some entries are "primary" (have an element).
// Some entries are covered by a primary (vertical or horizontal 1x2). Primary entries will have .span = [i] or [i, i+boardSize] or [i, i+1]
// Covered entries will have .coveredBy = primaryIndex and primary=false.
const cells = new Array(totalCells);

// --- Helper utilities ---
// Helpers for grid placements
function rcToIndex(r,c){ return r*boardSize + c; }
function indexToRC(idx){ return { r: Math.floor(idx/boardSize), c: idx%boardSize }; }

// utilities
// Small helper utilities used throughout the game
function shuffle(array){ for(let i=array.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [array[i],array[j]]=[array[j],array[i]];} return array; }
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
// Pick readable (black/white) text color based on hex background -- used to keep counters legible
function textColorForHex(hex){ const h=hex.replace('#',''); const r=parseInt(h.substring(0,2),16); const g=parseInt(h.substring(2,4),16); const b=parseInt(h.substring(4,6),16); return ((r*299+g*587+b*114)/1000)>150 ? '#000' : '#fff'; }

// --- NEW: improved placement algorithm for vertical + horizontal 1x2 spans ---
// Requirements implemented:
//  - no overlap
//  - no two spans orthogonally adjacent to each other (keeps them useful)
//  - include both vertical and horizontal spans
//  - scale number of spans with board size (small boards fewer, larger boards more)

// Manhattan distance helper (grid-based distance used to avoid adjacency when placing spans)
function manhattan(a,b){ const ar = Math.floor(a/boardSize), ac = a%boardSize; const br = Math.floor(b/boardSize), bc = b%boardSize; return Math.abs(ar-br) + Math.abs(ac-bc); }

const occupied = new Set();         // all occupied indices (covered by any span)
const primaryMap = {};              // primaryIndex -> { span: [i,...], orient: 'v'|'h' }

// If diffSquares flag is set, place a number of 1x2 spans across the board.
// The algorithm ensures:
//  - spans don't overlap
//  - spans aren't orthogonally adjacent to another span (keeps them useful)
//  - both vertical and horizontal spans are allowed
if (diffSquares) {
  // Determine target number of spans
  // Small boards: mild count; large boards: scale with area so bigger maps get noticeably more spans
  // below 7: keep previous conservative formula; from 7 onward scale with area
  let targetSpans;
  if (boardSize < 7) {
    targetSpans = Math.max(1, Math.round(boardSize / 3));
  } else {
    // around totalCells / 12 gives reasonable density (7x7 => ~4, 10x10 => ~8)
    targetSpans = Math.round(totalCells / 12);
  }
  // never exceed a third of possible primary cells
  const maxPossible = Math.floor(totalCells / 3);
  targetSpans = Math.max(1, Math.min(targetSpans, maxPossible));

  // Build candidate positions for both vertical and horizontal spans
  const candidates = [];
  for (let r=0;r<boardSize;r++){
    for (let c=0;c<boardSize;c++){
      const i = rcToIndex(r,c);
      // vertical candidate (top cell must not be bottom row)
      if (r < boardSize - 1) candidates.push({ idx: i, orient: 'v' });
      // horizontal candidate (left cell must not be rightmost column)
      if (c < boardSize - 1) candidates.push({ idx: i, orient: 'h' });
    }
  }
  shuffle(candidates);

  const placed = [];

  for (let k=0; k<candidates.length && placed.length < targetSpans; k++){
    const cand = candidates[k];
    const top = cand.idx;
    const rc = indexToRC(top);
    let covered;
    if (cand.orient === 'v') {
      covered = [ top, rcToIndex(rc.r + 1, rc.c) ];
    } else {
      covered = [ top, rcToIndex(rc.r, rc.c + 1) ];
    }

  // Availability: ensure none of the covered indices already occupied
    if (covered.some(ci => occupied.has(ci))) continue;

  // Ensure candidate is not orthogonally adjacent to any existing placed span
    let ok = true;
    for (const p of placed){
      const primCovered = p.span;
      for (const a of covered){
        for (const b of primCovered){
          if (manhattan(a,b) === 0) { ok = false; break; } // overlap (shouldn't happen)
          if (manhattan(a,b) === 1) { ok = false; break; } // orthogonally adjacent — disallowed
        }
        if (!ok) break;
      }
      if (!ok) break;
    }
    if (!ok) continue;

    // Accept candidate: mark occupied and record primary
    covered.forEach(ci => occupied.add(ci));
    primaryMap[top] = { span: covered.slice(), orient: cand.orient };
    placed.push({ top, span: covered.slice(), orient: cand.orient });
  }
  // done placement
}

// --- Create DOM elements for primary cells only ---
// Create only primary elements. Covered indices are represented in `cells` but don't get DOM nodes.
// Primaries that span two indices receive gridRowEnd or gridColumnEnd = `span 2`.
for (let r=0;r<boardSize;r++){
  for (let c=0;c<boardSize;c++){
    const i = rcToIndex(r,c);

    // If this index is a primaryMap key => create primary element with orientation
    if (primaryMap[i]){
      const info = primaryMap[i];
  const el = document.createElement('div');
  el.className = 'cell';
  el.dataset.index = i;
      if (info.orient === 'v'){
        el.style.gridRowStart = (r+1);
        el.style.gridRowEnd = `span 2`;
        el.style.gridColumnStart = (c+1);
      } else {
        el.style.gridRowStart = (r+1);
        el.style.gridColumnStart = (c+1);
        el.style.gridColumnEnd = `span 2`;
      }
  boardEl.appendChild(el);
      cells[i] = { index: i, element: el, owner: null, pieces: 0, primary: true, span: info.span.slice() };
      // mark covered (other) index as non-primary
      for (const ci of info.span){
        if (ci === i) continue;
        cells[ci] = { index: ci, element: null, owner: null, pieces: 0, primary: false, coveredBy: i };
      }
      continue;
    }

    // If this index is covered by someone else, skip DOM creation (it's part of a span)
    if (cells[i] && cells[i].primary === false) {
      continue;
    }

  // Normal single cell (non-spanning primary)
    const el = document.createElement('div');
    el.className = 'cell';
    el.dataset.index = i;
    el.style.gridRowStart = (r+1);
    el.style.gridColumnStart = (c+1);
    boardEl.appendChild(el);
    cells[i] = { index: i, element: el, owner: null, pieces: 0, primary: true, span: [i] };
  }
}

// helper: get primary cell object for an index/cell (always returns the primary cell)
function getPrimaryCell(objOrIndex){
  let idx = (typeof objOrIndex === 'number') ? objOrIndex : (objOrIndex && objOrIndex.index);
  if (idx == null) return null;
  const c = cells[idx];
  if (!c) return null;
  if (c.primary) return c;
  if (typeof c.coveredBy === 'number') return cells[c.coveredBy];
  return c;
}

// helper: covered indices for a cell index (returns array of grid indices)
function coveredIndicesFor(idx){
  const primary = getPrimaryCell(idx);
  if (!primary) return [];
  return primary.span || [primary.index];
}

// adjacency now respects spans: any covered subcell adjacent to any covered subcell counts
function isAdjacent(i1,i2){
  const aIndices = coveredIndicesFor(i1);
  const bIndices = coveredIndicesFor(i2);
  for (let ia of aIndices){
    const ra = Math.floor(ia/boardSize), ca = ia%boardSize;
    for (let ib of bIndices){
      const rb = Math.floor(ib/boardSize), cb = ib%boardSize;
      if (Math.abs(ra-rb)+Math.abs(ca-cb) === 1) return true;
    }
  }
  return false;
}

// render helpers
function updateCell(cell){
  // allow calling with either primary or covered cell
  const primary = getPrimaryCell(cell);
  if (!primary || !primary.element) return;
  const el = primary.element;
  if (primary.owner){
    const color = playerData[primary.owner-1].color;
    el.style.background = color;
    el.style.color = textColorForHex(color);
    let counter = el.querySelector('.cnt');
    if (!counter){ counter = document.createElement('div'); counter.className = 'cnt'; counter.style.pointerEvents='none'; el.innerHTML = ''; el.appendChild(counter); }
    counter.textContent = primary.pieces;
    el.title = `Player ${primary.owner} — Pieces: ${primary.pieces}`;
  } else {
    el.style.background = '#222';
    el.style.color = '#fff';
    el.innerHTML = '';
    el.title = 'Neutral';
  }
}

// animate numeric tween (always operate on primary cell)
function animateNumber(cellObj, newVal, duration = 500){
  const primary = getPrimaryCell(cellObj);
  if (!primary || !primary.element) return;
  const el = primary.element.querySelector('.cnt') || primary.element;
  const start = primary.pieces;
  const steps = Math.max(6, Math.floor(duration/40));
  let step = 0;
  const diff = newVal - start;
  const t = setInterval(()=>{
    step++;
    const val = Math.round(start + diff * (step / steps));
    el.textContent = val;
    if (step >= steps){
      clearInterval(t);
      el.textContent = newVal;
    }
  }, Math.max(8, duration/steps));
  primary.pieces = newVal;
}

// render player info badges
let roundCounter = 1; // increments when a full rotation of turns completes
let roundStartPlayer = 1; // the player id that marks the start of a round
// blockedAlliances holds objects {a: playerA, b: playerB, untilRound: n} preventing attacks between that pair until roundCounter >= untilRound
const blockedAlliances = [];

function recalcPlayerTotals(){ 
  playerData.forEach(p=>{p.territories=0;p.totalPieces=0});
  // count only primary cells as territories (so a 1x2 counts as 1 territory)
  cells.forEach(c=>{
    if (c && c.primary && c.owner){
      const p = playerData[c.owner-1];
      if (p){ p.territories++; p.totalPieces += c.pieces; }
    }
  });
  playerData.forEach(p=>p.alive = p.territories>0);
}
function clearAlliancePendingBetween(a,b){
  if (playerData[a-1]) playerData[a-1].pendingOfferTo = null;
  if (playerData[b-1]) playerData[b-1].pendingOfferFrom = null;
}

function offerAlliance(targetId){
  if (players < 3) { showBattleLog('Alliances disabled for 2-player games.'); return; }
  const from = currentPlayer;
  if (playerData[from-1].ally) { showBattleLog('You already have an ally.'); return; }
  if (playerData[targetId-1].ally) { showBattleLog('Target already allied.'); return; }
  // can't offer to yourself
  if (from === targetId) return;
  playerData[targetId-1].pendingOfferFrom = from;
  playerData[from-1].pendingOfferTo = targetId;
  renderPlayerInfo();
  showBattleLog(`Alliance offer sent to P${targetId}`);
}

function cancelOffer(targetId){
  const from = currentPlayer;
  if (playerData[from-1].pendingOfferTo === targetId) {
    playerData[from-1].pendingOfferTo = null;
    if (playerData[targetId-1]) playerData[targetId-1].pendingOfferFrom = null;
    renderPlayerInfo();
    showBattleLog(`Cancelled offer to P${targetId}`);
  }
}

function acceptAlliance(fromId){
  const target = currentPlayer;
  if (players < 3) { showBattleLog('Alliances disabled for 2-player games.'); return; }
  if (!playerData[target-1].pendingOfferFrom || playerData[target-1].pendingOfferFrom !== fromId) return;
  if (playerData[target-1].ally || playerData[fromId-1].ally) { clearAlliancePendingBetween(fromId, target); renderPlayerInfo(); return; }
  playerData[target-1].ally = fromId;
  playerData[fromId-1].ally = target;
  clearAlliancePendingBetween(fromId, target);
  renderPlayerInfo();
  showBattleLog(`P${target} and P${fromId} are now allies`);
}

function breakAllianceWith(targetId){
  const a = currentPlayer;
  const b = targetId;
  if (!playerData[a-1] || !playerData[b-1]) return;
  if (playerData[a-1].ally !== b && playerData[b-1].ally !== a) return;
  // break alliance and record blocked pair until next round
  playerData[a-1].ally = null;
  playerData[b-1].ally = null;
  const blockedUntil = roundCounter + 1;
  blockedAlliances.push({ a, b, untilRound: blockedUntil });
  clearAlliancePendingBetween(a,b);
  renderPlayerInfo();
  showBattleLog(`Alliance between P${a} and P${b} ended. They cannot be attacked until next round.`);
}

// render UI for player badges (offers/accept/break)
function renderPlayerInfo(){ recalcPlayerTotals(); infoEl.innerHTML=''; playerData.forEach(p=>{ const badge=document.createElement('div'); badge.className='player-badge';
    // base info
    const allyText = p.ally ? ` • Ally:P${p.ally}` : '';
    badge.innerHTML=`<div class="swatch" style="background:${p.color}"></div><div>P${p.id}${allyText}</div><div style="opacity:.7">T:${p.territories}</div><div style="opacity:.7">S:${p.totalPieces}</div>`;
    // alliance controls (only for 3+ players and not-self)
    if (players >= 3 && p.id !== currentPlayer){
      const ctrl = document.createElement('div'); ctrl.style.marginLeft='8px';
      // If this player is current player's ally -> show Break
      if (playerData[currentPlayer-1].ally === p.id){
        const btn = document.createElement('button'); btn.textContent='Break'; btn.addEventListener('click', ()=> breakAllianceWith(p.id)); ctrl.appendChild(btn);
      } else if (playerData[p.id-1].pendingOfferFrom === currentPlayer){
        // Offer pending: show cancel option for the offering player
        const btn = document.createElement('button'); btn.textContent='Cancel Offer'; btn.addEventListener('click', ()=> cancelOffer(p.id)); ctrl.appendChild(btn);
      } else if (playerData[currentPlayer-1].pendingOfferFrom === p.id){
        // Current player has an incoming offer from this player -> show Accept
        const btn = document.createElement('button'); btn.textContent='Accept'; btn.addEventListener('click', ()=> acceptAlliance(p.id)); ctrl.appendChild(btn);
      } else if (playerData[p.id-1].ally){
        // Target already allied with someone else — show disabled
        const span = document.createElement('span'); span.textContent='Ally'; span.style.opacity='0.6'; ctrl.appendChild(span);
      } else {
        const btn = document.createElement('button'); btn.textContent='Offer'; btn.addEventListener('click', ()=> offerAlliance(p.id)); ctrl.appendChild(btn);
      }
      badge.appendChild(ctrl);
    }
    infoEl.appendChild(badge);
  }); }

// --- Dice UI helpers and animations ---
// The dice overlay shows attacker/defender dice, animates face rolls and displays totals.
// Dice are represented as simple white squares with pip elements generated by `renderDieFace`.

// initial distribution (random round-robin) with random pieces 1..5,
// but only assign to primary cells and mirror ownership to covered indices so other code doesn't freak out.
function assignStartingCells(){
  const primaryIndices = [];
  for (let i=0;i<cells.length;i++){
    if (cells[i] && cells[i].primary) primaryIndices.push(i);
  }
  const indices = shuffle(primaryIndices.slice());
  for (let i=0;i<indices.length;i++){
    const idx = indices[i];
    const pIdx = i % players;
    const cell = cells[idx];
    const pieces = randInt(1,5);
    // assign owner/pieces to primary
    cell.owner = pIdx+1;
    cell.pieces = pieces;
    // mirror ownership to covered indices so lookups at either index see the same owner
    const span = cell.span || [idx];
    span.forEach(si => {
      if (si !== idx && cells[si]) {
        cells[si].owner = cell.owner;
        cells[si].pieces = cell.pieces; // mirror piece number but only primary will be shown/animated
      }
    });
    updateCell(cell);
  }
  renderPlayerInfo();
}

/* Reinforcement distribution */
const MAX_PAWNS_PER_CELL = 10;
function distributeReinforcementsForPlayer(playerId){
  // count primary-owned cells only for income calculation
  const ownedPrimaries = cells.filter(c=>c && c.primary && c.owner===playerId);
  if (ownedPrimaries.length === 0) return;
  const totalIncome = ownedPrimaries.length;
  if (totalIncome <= 0) return;

  let recipients = ownedPrimaries.filter(c => c.pieces < MAX_PAWNS_PER_CELL).map(c=>c.index);

  for (let i=0;i<totalIncome;i++){
    if (recipients.length === 0) break;
    const pick = recipients[Math.floor(Math.random()*recipients.length)];
    const cell = cells[pick];
    if (!cell) { recipients = recipients.filter(idx => idx !== pick); continue; }
    if (cell.pieces >= MAX_PAWNS_PER_CELL) { recipients = recipients.filter(idx => idx !== pick); continue; }

    // particle spawn (visual) - use primary element
    const rect = boardEl.getBoundingClientRect();
    const sx = rect.width/2;
    const sy = -20;
    const rectCell = cell.element.getBoundingClientRect();
    const panelRect = boardEl.getBoundingClientRect();
    const tx = rectCell.left + rectCell.width/2 - panelRect.left;
    const ty = rectCell.top + rectCell.height/2 - panelRect.top;
    const particle = document.createElement('div');
    particle.className = 'pawnParticle';
    particle.style.left = `${sx}px`; particle.style.top = `${sy}px`; particle.style.background = playerData[playerId-1].color; particle.style.opacity = '1';
    boardEl.appendChild(particle);
    requestAnimationFrame(()=>{ particle.style.left = `${tx}px`; particle.style.top = `${ty}px`; particle.style.transform = 'translate(-50%,-50%) scale(1.05)'; });
    setTimeout(()=>{ particle.style.opacity='0'; setTimeout(()=>{ particle.remove(); }, 480); }, 600);

    setTimeout(()=>{
      if (cell.pieces < MAX_PAWNS_PER_CELL) {
        animateNumber(cell, Math.min(MAX_PAWNS_PER_CELL, cell.pieces+1), 360);
        // also mirror pieces to covered indices so saves/load and other logic stay consistent
        const span = cell.span || [cell.index];
        span.forEach(si => { if (cells[si] && !cells[si].primary) cells[si].pieces = cell.pieces; });
        renderPlayerInfo();
        if (cell.pieces >= MAX_PAWNS_PER_CELL) {
          recipients = recipients.filter(idx => idx !== pick);
        }
      }
    }, 420 + Math.random()*120);
  }
}

/* Audio helpers (unchanged) */
const AudioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
function playTone(freq, dur=0.08, type='sine', gain=0.09){ if (!AudioCtx) return; const o = AudioCtx.createOscillator(); const g = AudioCtx.createGain(); o.type = type; o.frequency.value = freq; g.gain.value = gain; o.connect(g); g.connect(AudioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, AudioCtx.currentTime + dur); setTimeout(()=> o.stop(), dur*1000+20); }
function playDiceRollSound(){ playTone(1200,0.05,'square',0.08); setTimeout(()=> playTone(950,0.05,'square',0.07), 60); setTimeout(()=> playTone(700,0.05,'square',0.06), 120); }
function playCaptureSound(){ playTone(520,0.18,'sawtooth',0.14); setTimeout(()=> playTone(860,0.12,'triangle',0.06), 120); }
function playDefendSound(){ playTone(220,0.14,'sine',0.12); setTimeout(()=> playTone(140,0.08,'sine',0.06), 90); }

// dice rendering as pips (white dice, dark pips)
const diePipsMap = {
  1: [4],
  2: [0,8],
  3: [0,4,8],
  4: [0,2,6,8],
  5: [0,2,4,6,8],
  6: [0,2,3,5,6,8]
};
function renderDieFace(dieEl, value){
  dieEl.innerHTML = '';
  for (let i=0;i<9;i++){
    const slot = document.createElement('div');
    slot.style.width = '100%'; slot.style.height = '100%';
    slot.style.display = 'flex'; slot.style.alignItems='center'; slot.style.justifyContent='center';
    if (diePipsMap[value] && diePipsMap[value].includes(i)){
      const pip = document.createElement('div');
      pip.className = 'pip';
      slot.appendChild(pip);
    }
    dieEl.appendChild(slot);
  }
}

function showBattleLog(text, short=true){
  battleLogEl.textContent = text;
  battleLogEl.classList.add('show');
  clearTimeout(battleLogEl._t);
  battleLogEl._t = setTimeout(()=> battleLogEl.classList.remove('show'), short ? 1400 : 3200);
}

function clearDiceUI(){ attRow.innerHTML=''; defRow.innerHTML=''; attTotalEl.textContent='0'; defTotalEl.textContent='0'; attCountEl.textContent='0'; defCountEl.textContent='0'; }
function showDiceOverlay(attCount, defCount){
  // Make overlay visible via aria-hidden — CSS handles display
  // remove any inline display:none set by hide functions so CSS can show it again
  battleOverlay.style.display = '';
  battleOverlay.setAttribute('aria-hidden','false');
  attCountEl.textContent = attCount;
  defCountEl.textContent = defCount;
  clearDiceUI();
  for(let i=0;i<attCount;i++){ const d = document.createElement('div'); d.className = 'diceDie'; attRow.appendChild(d); }
  for(let i=0;i<defCount;i++){ const d = document.createElement('div'); d.className = 'diceDie'; defRow.appendChild(d); }
}
function hideDiceOverlayAfter(ms=3000){ clearTimeout(diceHideTimer); diceHideTimer = setTimeout(()=>{ battleOverlay.style.display='none'; battleOverlay.setAttribute('aria-hidden','true'); clearDiceUI(); }, ms); }
function hideDiceOverlayNow(){ clearTimeout(diceHideTimer); battleOverlay.style.display='none'; battleOverlay.setAttribute('aria-hidden','true'); clearDiceUI(); }

function rollDiceArray(n){ const out = []; for(let i=0;i<n;i++) out.push(randInt(1,6)); return out; }
function sumDice(arr){ return arr.reduce((a,b)=>a+b,0); }

function animateDiceRollFaces(finalAtt, finalDef, onDone){
  const attDice = Array.from(attRow.children);
  const defDice = Array.from(defRow.children);
  const rollTime = 1100;
  const interval = 80;
  const rounds = Math.floor(rollTime / interval);
  let r = 0;
  playDiceRollSound();
  const intervalId = setInterval(()=>{
    r++;
    attDice.forEach(d => renderDieFace(d, randInt(1,6)));
    defDice.forEach(d => renderDieFace(d, randInt(1,6)));
    if (r >= rounds){
      clearInterval(intervalId);
      attDice.forEach((d,i)=> renderDieFace(d, (finalAtt[i]||1)));
      defDice.forEach((d,i)=> renderDieFace(d, (finalDef[i]||1)));
      if (typeof onDone === 'function') onDone();
    }
  }, interval);
}

/* pawn animation */
function animatePawnTransfer(srcEl, tgtEl, color, count=1){
  const rectSrc = srcEl.getBoundingClientRect();
  const rectTgt = tgtEl.getBoundingClientRect();
  const panelRect = boardEl.getBoundingClientRect();
  const sx = rectSrc.left + rectSrc.width/2 - panelRect.left;
  const sy = rectSrc.top + rectSrc.height/2 - panelRect.top;
  const tx = rectTgt.left + rectTgt.width/2 - panelRect.left;
  const ty = rectTgt.top + rectTgt.height/2 - panelRect.top;

  const spawn = Math.min(6, Math.max(1, count));
  for (let i=0;i<spawn;i++){
    const particle = document.createElement('div');
    particle.className = 'pawnParticle';
    particle.style.left = `${sx + randInt(-6,6)}px`;
    particle.style.top = `${sy + randInt(-6,6)}px`;
    particle.style.background = color;
    particle.style.opacity = '1';
    boardEl.appendChild(particle);
    requestAnimationFrame(()=>{ particle.style.left = `${tx + randInt(-8,8)}px`; particle.style.top = `${ty + randInt(-8,8)}px`; particle.style.transform = 'translate(-50%,-50%) scale(1.15)'; });
    setTimeout(()=>{ particle.style.opacity='0'; setTimeout(()=> particle.remove(), 460); }, 580 + i*40);
  }
}

function shakeBoard(){ boardEl.classList.add('shake'); setTimeout(()=> boardEl.classList.remove('shake'), 450); }

/* Attack flow */
let locked = false;
function performAttackAnimated(srcIdx, tgtIdx){
  // High-level flow:
  // - Validate attack conditions (ownership, adjacency, pieces)
  // - Determine dice counts and show dice overlay
  // - Roll dice, animate faces, compute sums
  // - If attacker wins: animate pawn transfer, change owner/pieces on target
  // - If defender wins: decrement attacker pieces
  // - Recompute and render player info, and re-enable UI after a short delay
  if (locked) return;
  const src = getPrimaryCell(srcIdx);
  const tgt = getPrimaryCell(tgtIdx);
  if (!src || !tgt) return;
  if (src.owner !== currentPlayer) return;
  if (!tgt.owner || tgt.owner === currentPlayer) return;
  // Disallow attacks between allies
  const attacker = currentPlayer;
  const defender = tgt.owner;
  if (players >= 3){
    if (playerData[attacker-1].ally === defender && playerData[defender-1].ally === attacker){
      showBattleLog('Cannot attack an ally.');
      return;
    }
    // Check blockedAlliances (recently broken)
    for (const b of blockedAlliances){
      if ( (b.a === attacker && b.b === defender) || (b.a === defender && b.b === attacker) ){
        if (roundCounter < b.untilRound){ showBattleLog('Cannot attack this player until next round.'); return; }
      }
    }
  }
  if (!isAdjacent(src.index, tgt.index)) return;

  const commitRaw = Math.max(0, src.pieces - 1);
  if (commitRaw <= 0){ showBattleLog('Cannot attack — must leave 1 behind.'); return; }

  const ATTACKER_DICE_CAP = 6;
  const DEFENDER_DICE_CAP = 6;
  const commit = Math.min(commitRaw, ATTACKER_DICE_CAP);
  const defDiceCount = Math.min(tgt.pieces, DEFENDER_DICE_CAP);

  locked = true;
  showDiceOverlay(commit, defDiceCount);

  const attDiceArr = rollDiceArray(commit);
  const defDiceArr = rollDiceArray(defDiceCount);

  animateDiceRollFaces(attDiceArr, defDiceArr, ()=>{
    const attSum = sumDice(attDiceArr);
    const defSum = sumDice(defDiceArr);
    attTotalEl.textContent = attSum;
    defTotalEl.textContent = defSum;

    const summary = `P${currentPlayer} (${attSum}) vs P${tgt.owner} (${defSum})`;

    if (attSum > defSum){
      playCaptureSound();
      animatePawnTransfer(src.element, tgt.element, playerData[currentPlayer-1].color, Math.min(8, commitRaw));
      const newSrcPieces = Math.max(1, src.pieces - commitRaw);
      animateNumber(src, newSrcPieces, 500);

      setTimeout(()=>{
        // capture: set owner/pieces of primary (and mirror to covered indices)
        tgt.owner = currentPlayer;
        updateCell(tgt);
        const moveIn = Math.min(commitRaw, Math.max(1, commitRaw));
        animateNumber(tgt, moveIn, 600);
        // ensure mirrored indices reflect same owner/pieces
        (tgt.span || [tgt.index]).forEach(si => {
          if (cells[si]) {
            cells[si].owner = currentPlayer;
            cells[si].pieces = moveIn;
          }
        });
        renderPlayerInfo();
      }, 220);

      tgt.element.classList.add('flash-capture');
      setTimeout(()=> tgt.element.classList.remove('flash-capture'), 900);
      if (commitRaw >= 4 || defSum >= 8) shakeBoard();
      showBattleLog('Capture! ' + summary);

  // Keep overlay visible for a bit to allow the player to see results, then hide and unlock input
  hideDiceOverlayAfter(3000);
  setTimeout(()=>{ locked = false; if (!(src.owner === currentPlayer && src.pieces > 1)) clearSelection(); renderPlayerInfo(); checkPlayerElimination(); checkWinCondition(); }, 3000);

    } else {
      playDefendSound();
      const newSrcPieces = Math.max(1, src.pieces - commitRaw);
      animateNumber(src, newSrcPieces, 500);
      src.element.classList.add('flash-defend');
      setTimeout(()=> src.element.classList.remove('flash-defend'), 700);
      showBattleLog('Defended. ' + summary);
      // Defender held: show defend animation and then hide overlay/unlock
      hideDiceOverlayAfter(3000);
      setTimeout(()=>{ locked = false; if (!(src.owner === currentPlayer && src.pieces > 1)) clearSelection(); renderPlayerInfo(); checkPlayerElimination(); checkWinCondition(); }, 3000);
    }
  });
}

/* Turn state & UI interactions */
let currentPlayer = 1;
function updateTurnDisplay() { turnDisplay.textContent = `Player ${currentPlayer}'s Turn`; turnDisplay.style.color = playerData[currentPlayer - 1].color; }
function nextAlivePlayer(from){ for (let step=1; step<=players; step++){ const cand = ((from-1+step) % players) + 1; if (playerData[cand-1].alive) return cand; } return null; }
let endTurnCooldown = 0; let endTurnTimer = null;
function startEndTurnCooldown(seconds = 5) { endTurnBtn.disabled = true; endTurnCooldown = seconds; endTurnBtn.textContent = `End Turn (${endTurnCooldown})`; clearInterval(endTurnTimer); endTurnTimer = setInterval(() => { endTurnCooldown--; if (endTurnCooldown > 0) { endTurnBtn.textContent = `End Turn (${endTurnCooldown})`; } else { clearInterval(endTurnTimer); endTurnBtn.disabled = false; endTurnBtn.textContent = "End Turn"; } }, 1000); }

// endTurn button handling is wired later to support round tracking

// Advance roundCounter when we complete a full rotation of turns
function advanceToNextPlayer(){
  const nxt = nextAlivePlayer(currentPlayer);
  if (nxt !== null && nxt !== currentPlayer) {
    currentPlayer = nxt;
    // if we've wrapped around to roundStartPlayer, increment round
    if (currentPlayer === roundStartPlayer){
      roundCounter++;
      // clear expired blockedAlliances
      for (let i = blockedAlliances.length-1; i>=0; i--){
        if (roundCounter >= blockedAlliances[i].untilRound) blockedAlliances.splice(i,1);
      }
    }
    updateTurnDisplay();
    setTimeout(()=>{ renderPlayerInfo(); checkWinCondition(); }, 420);
    startEndTurnCooldown(5);
  }
}

// wire the existing endTurn button to new flow
endTurnBtn.removeEventListener('click', ()=>{});
endTurnBtn.addEventListener('click', ()=>{ if (locked || endTurnBtn.disabled) return; distributeReinforcementsForPlayer(currentPlayer); advanceToNextPlayer(); });

function clearSelection(){ if (typeof selectedCell !== 'undefined' && selectedCell !== null) { const selPrimary = getPrimaryCell(selectedCell); if (selPrimary && selPrimary.element) selPrimary.element.classList.remove('selected'); } selectedCell=null; }
let selectedCell = null;

function handleCellSelect(ev){
  if (locked) return;
  const el = ev.target.closest('.cell');
  if (!el) return;
  const idx = Number(el.dataset.index);
  const c = getPrimaryCell(idx);
  if (!c) return;
  if (selectedCell === null){
    if (c.owner === currentPlayer){
      selectedCell = c.index;
      c.element.classList.add('selected');
    }
    return;
  }
  if (selectedCell === c.index){
    clearSelection();
    return;
  }
  const newCell = getPrimaryCell(idx);
  if (newCell.owner === currentPlayer){
    const prev = getPrimaryCell(selectedCell);
    if (prev && prev.element) prev.element.classList.remove('selected');
    selectedCell = newCell.index;
    if (newCell.element) newCell.element.classList.add('selected');
    return;
  }
  if (newCell.owner && newCell.owner !== currentPlayer){
    if (!isAdjacent(selectedCell, newCell.index)){
      el.animate([{transform:'translateY(0)'},{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:160});
      return;
    }
    performAttackAnimated(selectedCell, newCell.index);
  }
}

// Listen for both click and touchstart
boardEl.addEventListener('click', handleCellSelect);
boardEl.addEventListener('touchstart', function(ev){
  // Only handle single-finger taps
  if (ev.touches.length === 1) {
    handleCellSelect(ev);
    ev.preventDefault();
  }
}, {passive: false});

/* Improve outside click clearing */
document.addEventListener('click', (ev)=>{ if (!ev.target.closest('.cell') && !ev.target.closest('button') && !ev.target.closest('#diceBox')){ clearSelection(); } });
boardEl.addEventListener('dblclick', (ev)=>{ const el = ev.target.closest('.cell'); if (!el) return; const idx = Number(el.dataset.index); console.log(getPrimaryCell(idx)); });

/* Close button handler: hide overlay immediately (UI only) */
diceCloseBtn.addEventListener('click', ()=>{ hideDiceOverlayNow(); });

/* Player elimination & win checks */
function checkPlayerElimination(){ recalcPlayerTotals(); }
function checkWinCondition(){ recalcPlayerTotals(); const alivePlayers = playerData.filter(p=>p.alive); if (alivePlayers.length === 1){ const winner = alivePlayers[0]; setTimeout(()=> alert(`Player ${winner.id} wins!`), 40); } }

/*
  Save / Load

  - saveGameState: serializes the minimal representation of the board (owner & pieces per index),
    playerData (to preserve colours/totals), boardSize and diffSquares to localStorage.
  - loadGameState: validates the saved state, maps owners/pieces back to our `cells` array and
    updates primary DOM elements. It preserves compatibility by storing values per-grid-index.
*/
function saveGameState() { 
  // Save owner/pieces for every grid index so save/load remains compatible
  const state = {
    currentPlayer,
    cells: cells.map(c => ({ owner: c ? c.owner : null, pieces: c ? c.pieces : 0 })),
    playerData: playerData.map(p => ({ id: p.id, color: p.color, territories: p.territories, totalPieces: p.totalPieces, alive: p.alive, ally: p.ally })),
    blockedAlliances,
    roundCounter,
    boardSize,
    diffSquares
  };
  try { localStorage.setItem('squareLordsSave', JSON.stringify(state)); alert('Game state saved!'); } catch (e) { console.error('Save failed', e); alert('Failed to save game state.'); } 
}
function loadGameState() { 
  const raw = localStorage.getItem('squareLordsSave'); 
  if (!raw) { alert('No save found.'); return false; } 
  try { const state = JSON.parse(raw); if (!state || !Array.isArray(state.cells) || state.cells.length !== cells.length){ alert('Incompatible save data.'); return false; } 
    state.cells.forEach((c, i) => { 
      if (!cells[i]) return;
      // Map saved owner/pieces onto our cells; primary cells are the authoritative visual ones
      cells[i].owner = c.owner;
      cells[i].pieces = c.pieces;
    }); 
    // After load, ensure primary elements reflect mirrored pieces for their covered indices
    for (let i=0;i<cells.length;i++){
      const pr = getPrimaryCell(i);
      if (pr && pr.element) updateCell(pr);
    }
  if (typeof state.currentPlayer === 'number') currentPlayer = state.currentPlayer; 
  if (Array.isArray(state.playerData)){ state.playerData.forEach((p, i) => { if (playerData[i]) Object.assign(playerData[i], p); }); }
  if (Array.isArray(state.blockedAlliances)) { blockedAlliances.length = 0; state.blockedAlliances.forEach(b => { if (b && typeof b.a === 'number' && typeof b.b === 'number' && typeof b.untilRound === 'number') blockedAlliances.push(b); }); }
  if (typeof state.roundCounter === 'number') roundCounter = state.roundCounter;
  updateTurnDisplay(); renderPlayerInfo(); alert('Game loaded.'); return true; 
  } catch (e) { console.error('Failed to load save:', e); alert('Failed to load save data.'); return false; } 
}
saveBtn.addEventListener('click', saveGameState);
loadBtn.addEventListener('click', loadGameState);

/* Initialization */
// Populate board with initial ownership/pieces and refresh UI
assignStartingCells();
updateTurnDisplay();

</script>
</body>
</html>
